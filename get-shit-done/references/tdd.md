<overview>
TDD — это про качество дизайна, а не про метрики покрытия. Цикл красный-зелёный-рефакторинг заставляет думать о поведении до реализации, создавая более чистые интерфейсы и более тестируемый код.

**Принцип:** Если вы можете описать поведение как `expect(fn(input)).toBe(output)` до написания `fn`, TDD улучшит результат.

**Ключевое наблюдение:** Работа по TDD принципиально тяжелее обычных задач — она требует 2-3 циклов выполнения (КРАСНЫЙ → ЗЕЛЁНЫЙ → РЕФАКТОРИНГ), каждый с чтением файлов, запуском тестов и потенциальной отладкой. TDD-фичи получают отдельные планы для обеспечения полного контекста на протяжении всего цикла.
</overview>

<when_to_use_tdd>
## Когда TDD улучшает качество

**Кандидаты для TDD (создать TDD-план):**
- Бизнес-логика с определёнными входами/выходами
- API-эндпоинты с контрактами запрос/ответ
- Трансформации данных, парсинг, форматирование
- Правила валидации и ограничения
- Алгоритмы с тестируемым поведением
- Конечные автоматы и рабочие процессы
- Утилитные функции с чёткими спецификациями

**Пропустить TDD (использовать стандартный план с задачами `type="auto"`):**
- Вёрстка UI, стили, визуальные компоненты
- Изменения конфигурации
- Связующий код между существующими компонентами
- Одноразовые скрипты и миграции
- Простой CRUD без бизнес-логики
- Исследовательское прототипирование

**Эвристика:** Можете ли вы написать `expect(fn(input)).toBe(output)` до написания `fn`?
→ Да: Создайте TDD-план
→ Нет: Используйте стандартный план, добавьте тесты после при необходимости
</when_to_use_tdd>

<tdd_plan_structure>
## Структура TDD-плана

Каждый TDD-план реализует **одну фичу** через полный цикл КРАСНЫЙ-ЗЕЛЁНЫЙ-РЕФАКТОРИНГ.

```markdown
---
phase: XX-name
plan: NN
type: tdd
---

<objective>
[Какая фича и зачем]
Цель: [Преимущество TDD-дизайна для этой фичи]
Результат: [Работающая, протестированная фича]
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@relevant/source/files.ts
</context>

<feature>
  <n>[Название фичи]</n>
  <files>[исходный файл, файл тестов]</files>
  <behavior>
    [Ожидаемое поведение в тестируемых терминах]
    Кейсы: вход → ожидаемый выход
  </behavior>
  <implementation>[Как реализовать когда тесты пройдут]</implementation>
</feature>

<verification>
[Команда запуска тестов, доказывающая работоспособность фичи]
</verification>

<success_criteria>
- Падающий тест написан и закоммичен
- Реализация проходит тест
- Рефакторинг завершён (при необходимости)
- Все 2-3 коммита присутствуют
</success_criteria>

<o>
После завершения создайте SUMMARY.md с:
- КРАСНЫЙ: Какой тест написан, почему он упал
- ЗЕЛЁНЫЙ: Какая реализация заставила его пройти
- РЕФАКТОРИНГ: Какая очистка выполнена (если есть)
- Коммиты: Список созданных коммитов
</o>
```

**Одна фича на TDD-план.** Если фичи достаточно тривиальны для объединения, они достаточно тривиальны чтобы пропустить TDD — используйте стандартный план и добавьте тесты после.
</tdd_plan_structure>

<execution_flow>
## Цикл Красный-Зелёный-Рефакторинг

**КРАСНЫЙ — Написать падающий тест:**
1. Создать файл теста следуя конвенциям проекта
2. Написать тест описывающий ожидаемое поведение (из элемента `<behavior>`)
3. Запустить тест — он ДОЛЖЕН упасть
4. Если тест проходит: фича уже существует или тест неверен. Расследовать.
5. Коммит: `test({phase}-{plan}): add failing test for [feature]`

**ЗЕЛЁНЫЙ — Реализовать для прохождения:**
1. Написать минимальный код для прохождения теста
2. Без ухищрений, без оптимизации — просто заставить работать
3. Запустить тест — он ДОЛЖЕН пройти
4. Коммит: `feat({phase}-{plan}): implement [feature]`

**РЕФАКТОРИНГ (при необходимости):**
1. Очистить реализацию если есть очевидные улучшения
2. Запустить тесты — ДОЛЖНЫ по-прежнему проходить
3. Коммитить только если изменения сделаны: `refactor({phase}-{plan}): clean up [feature]`

**Результат:** Каждый TDD-план создаёт 2-3 атомарных коммита.
</execution_flow>

<test_quality>
## Хорошие тесты vs Плохие тесты

**Тестируйте поведение, а не реализацию:**
- Хорошо: "возвращает отформатированную строку даты"
- Плохо: "вызывает хелпер formatDate с правильными параметрами"
- Тесты должны переживать рефакторинг

**Одна концепция на тест:**
- Хорошо: Отдельные тесты для валидного ввода, пустого ввода, некорректного ввода
- Плохо: Один тест проверяющий все граничные случаи с множеством утверждений

**Описательные названия:**
- Хорошо: "should reject empty email", "returns null for invalid ID"
- Плохо: "test1", "handles error", "works correctly"

**Без деталей реализации:**
- Хорошо: Тестировать публичный API, наблюдаемое поведение
- Плохо: Мокать внутренности, тестировать приватные методы, проверять внутреннее состояние
</test_quality>

<framework_setup>
## Настройка тестового фреймворка (если отсутствует)

Когда выполняется TDD-план, но тестовый фреймворк не настроен, настройте его в КРАСНОЙ фазе:

**1. Определить тип проекта:**
```bash
# JavaScript/TypeScript
if [ -f package.json ]; then echo "node"; fi

# Python
if [ -f requirements.txt ] || [ -f pyproject.toml ]; then echo "python"; fi

# Go
if [ -f go.mod ]; then echo "go"; fi

# Rust
if [ -f Cargo.toml ]; then echo "rust"; fi
```

**2. Установить минимальный фреймворк:**
| Проект | Фреймворк | Установка |
|---------|-----------|---------|
| Node.js | Jest | `npm install -D jest @types/jest ts-jest` |
| Node.js (Vite) | Vitest | `npm install -D vitest` |
| Python | pytest | `pip install pytest` |
| Go | testing | Встроенный |
| Rust | cargo test | Встроенный |

**3. Создать конфиг при необходимости:**
- Jest: `jest.config.js` с пресетом ts-jest
- Vitest: `vitest.config.ts` с test globals
- pytest: `pytest.ini` или секция в `pyproject.toml`

**4. Проверить настройку:**
```bash
# Запустить пустой набор тестов — должен пройти с 0 тестами
npm test  # Node
pytest    # Python
go test ./...  # Go
cargo test    # Rust
```

**5. Создать первый тестовый файл:**
Следуйте конвенциям проекта для расположения тестов:
- `*.test.ts` / `*.spec.ts` рядом с исходником
- Каталог `__tests__/`
- Каталог `tests/` в корне

Настройка фреймворка — одноразовая стоимость, включённая в КРАСНУЮ фазу первого TDD-плана.
</framework_setup>

<error_handling>
## Обработка ошибок

**Тест не падает в КРАСНОЙ фазе:**
- Фича может уже существовать — расследовать
- Тест может быть неверен (тестирует не то, что предполагалось)
- Исправить перед продолжением

**Тест не проходит в ЗЕЛЁНОЙ фазе:**
- Отладить реализацию
- Не переходить к рефакторингу
- Продолжать итерации пока не станет зелёным

**Тесты падают в фазе РЕФАКТОРИНГА:**
- Отменить рефакторинг
- Коммит был преждевременным
- Рефакторить более мелкими шагами

**Несвязанные тесты ломаются:**
- Остановиться и расследовать
- Может указывать на проблему связанности
- Исправить перед продолжением
</error_handling>

<commit_pattern>
## Паттерн коммитов для TDD-планов

TDD-планы создают 2-3 атомарных коммита (по одному на фазу):

```
test(08-02): add failing test for email validation

- Тесты валидных форматов email принимаются
- Тесты невалидных форматов отклоняются
- Тесты обработки пустого ввода

feat(08-02): implement email validation

- Regex-паттерн соответствует RFC 5322
- Возвращает boolean для валидности
- Обрабатывает граничные случаи (пусто, null)

refactor(08-02): extract regex to constant (опционально)

- Паттерн вынесен в константу EMAIL_REGEX
- Без изменений поведения
- Тесты по-прежнему проходят
```

**Сравнение со стандартными планами:**
- Стандартные планы: 1 коммит на задачу, 2-4 коммита на план
- TDD-планы: 2-3 коммита на одну фичу

Оба следуют одному формату: `{type}({phase}-{plan}): {description}`

**Преимущества:**
- Каждый коммит можно откатить независимо
- Git bisect работает на уровне коммитов
- Чёткая история, показывающая TDD-дисциплину
- Согласуется с общей стратегией коммитов
</commit_pattern>

<context_budget>
## Бюджет контекста

TDD-планы нацелены на **~40% использования контекста** (ниже чем ~50% для стандартных планов).

Почему ниже:
- КРАСНАЯ фаза: написать тест, запустить тест, возможно отладить почему не упал
- ЗЕЛЁНАЯ фаза: реализовать, запустить тест, возможно итерировать по сбоям
- РЕФАКТОРИНГ: модифицировать код, запустить тесты, проверить отсутствие регрессий

Каждая фаза включает чтение файлов, запуск команд, анализ вывода. Обмен данными по природе тяжелее чем линейное выполнение задач.

Фокус на одной фиче обеспечивает полное качество на протяжении всего цикла.
</context_budget>
