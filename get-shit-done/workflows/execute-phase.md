<purpose>
Выполнить все планы фазы используя волновое параллельное выполнение. Оркестратор остаётся лёгким — делегирует выполнение планов субагентам.
</purpose>

<core_principle>
Оркестратор координирует, не выполняет. Каждый субагент загружает полный контекст execute-plan. Оркестратор: обнаружить планы → проанализировать зависимости → сгруппировать волны → запустить агентов → обработать контрольные точки → собрать результаты.
</core_principle>

<required_reading>
Прочитайте STATE.md перед любой операцией для загрузки контекста проекта.
</required_reading>

<process>

<step name="initialize" priority="first">
Загрузить весь контекст одним вызовом:

```bash
INIT=$(node ~/.claude/get-shit-done/bin/gsd-tools.js init execute-phase "${PHASE_ARG}")
```

Распарсить JSON: `executor_model`, `verifier_model`, `commit_docs`, `parallelization`, `branching_strategy`, `branch_name`, `phase_found`, `phase_dir`, `phase_number`, `phase_name`, `phase_slug`, `plans`, `incomplete_plans`, `plan_count`, `incomplete_count`, `state_exists`, `roadmap_exists`.

**Если `phase_found` — false:** Ошибка — каталог фазы не найден.
**Если `plan_count` — 0:** Ошибка — планы в фазе не найдены.
**Если `state_exists` — false но `.planning/` существует:** Предложить реконструировать или продолжить.

Когда `parallelization` — false, планы внутри волны выполняются последовательно.
</step>

<step name="handle_branching">
Проверить `branching_strategy` из init:

**"none":** Пропустить, продолжить на текущей ветке.

**"phase" или "milestone":** Использовать предвычисленное `branch_name` из init:
```bash
git checkout -b "$BRANCH_NAME" 2>/dev/null || git checkout "$BRANCH_NAME"
```

Все последующие коммиты идут в эту ветку. Пользователь управляет слиянием.
</step>

<step name="validate_phase">
Из JSON инициализации: `phase_dir`, `plan_count`, `incomplete_count`.

Сообщить: "Найдено {plan_count} планов в {phase_dir} ({incomplete_count} незавершённых)"
</step>

<step name="discover_and_group_plans">
Загрузить инвентарь планов с группировкой по волнам одним вызовом:

```bash
PLAN_INDEX=$(node ~/.claude/get-shit-done/bin/gsd-tools.js phase-plan-index "${PHASE_NUMBER}")
```

Распарсить JSON: `phase`, `plans[]` (каждый с `id`, `wave`, `autonomous`, `objective`, `files_modified`, `task_count`, `has_summary`), `waves` (карта номер волны → ID планов), `incomplete`, `has_checkpoints`.

**Фильтрация:** Пропустить планы где `has_summary: true`. Если `--gaps-only`: также пропустить не-gap_closure планы. Если все отфильтрованы: "Нет подходящих незавершённых планов" → выход.

Сообщить:
```
## План выполнения

**Фаза {X}: {Название}** — {total_plans} планов в {wave_count} волнах

| Волна | Планы | Что строится |
|-------|-------|-------------|
| 1 | 01-01, 01-02 | {из целей планов, 3-8 слов} |
| 2 | 01-03 | ... |
```
</step>

<step name="execute_waves">
Выполнять каждую волну последовательно. Внутри волны: параллельно если `PARALLELIZATION=true`, последовательно если `false`.

**Для каждой волны:**

1. **Описать что строится (ПЕРЕД запуском):**

   Прочитать `<objective>` каждого плана. Извлечь что строится и зачем.

   ```
   ---
   ## Волна {N}

   **{ID плана}: {Название плана}**
   {2-3 предложения: что строится, технический подход, почему это важно}

   Запуск {count} агента(ов)...
   ---
   ```

   - Плохо: "Выполняется план генерации ландшафта"
   - Хорошо: "Процедурный генератор ландшафта на шуме Перлина — создаёт карты высот, биомные зоны и коллизионные меши. Требуется до того, как физика транспорта сможет взаимодействовать с землёй."

2. **Запустить агентов-исполнителей:**

   Передать только пути — исполнители читают файлы сами с их свежим контекстом 200k.
   Это сохраняет контекст оркестратора лёгким (~10-15%).

   ```
   Task(
     subagent_type="gsd-executor",
     model="{executor_model}",
     prompt="
       <objective>
       Execute plan {plan_number} of phase {phase_number}-{phase_name}.
       Commit each task atomically. Create SUMMARY.md. Update STATE.md.
       </objective>

       <execution_context>
       @~/.claude/get-shit-done/workflows/execute-plan.md
       @~/.claude/get-shit-done/templates/summary.md
       @~/.claude/get-shit-done/references/checkpoints.md
       @~/.claude/get-shit-done/references/tdd.md
       </execution_context>

       <files_to_read>
       Read these files at execution start using the Read tool:
       - Plan: {phase_dir}/{plan_file}
       - State: .planning/STATE.md
       - Config: .planning/config.json (if exists)
       </files_to_read>

       <success_criteria>
       - [ ] All tasks executed
       - [ ] Each task committed individually
       - [ ] SUMMARY.md created in plan directory
       - [ ] STATE.md updated with position and decisions
       </success_criteria>
     "
   )
   ```

3. **Дождаться завершения всех агентов в волне.**

4. **Отчитаться о завершении — сначала выборочная проверка:**

   Для каждого SUMMARY.md:
   - Проверить что первые 2 файла из `key-files.created` существуют на диске
   - Проверить что `git log --oneline --all --grep="{phase}-{plan}"` возвращает ≥1 коммит
   - Проверить наличие маркера `## Self-Check: FAILED`

   Если ЛЮБАЯ выборочная проверка провалилась: сообщить какой план провалился, направить в обработчик ошибок — спросить "Повторить план?" или "Продолжить с оставшимися волнами?"

   Если проверка пройдена:
   ```
   ---
   ## Волна {N} завершена

   **{ID плана}: {Название плана}**
   {Что было построено — из SUMMARY.md}
   {Заметные отклонения, если есть}

   {Если есть ещё волны: что это даёт для следующей волны}
   ---
   ```

   - Плохо: "Волна 2 завершена. Переход к волне 3."
   - Хорошо: "Система ландшафта завершена — 3 типа биомов, текстурирование по высоте, коллизионные меши. Физика транспорта (Волна 3) теперь может использовать поверхности земли."

5. **Обработка ошибок:**

   **Известный баг Claude Code (classifyHandoffIfNeeded):** Если агент сообщает "failed" с ошибкой содержащей `classifyHandoffIfNeeded is not defined`, это баг рантайма Claude Code — не GSD и не агента. Ошибка срабатывает в обработчике завершения ПОСЛЕ выполнения всех вызовов инструментов. В этом случае: выполнить те же выборочные проверки что в шаге 4 (SUMMARY.md существует, коммиты есть, нет Self-Check: FAILED). Если проверки ПРОЙДЕНЫ → считать **успешным**. Если проверки ПРОВАЛЕНЫ → считать реальной ошибкой ниже.

   Для реальных ошибок: сообщить какой план провалился → спросить "Продолжить?" или "Остановить?" → если продолжить, зависимые планы тоже могут провалиться. Если остановить, частичный отчёт о завершении.

6. **Выполнить планы контрольных точек между волнами** — см. `<checkpoint_handling>`.

7. **Перейти к следующей волне.**
</step>

<step name="checkpoint_handling">
Планы с `autonomous: false` требуют взаимодействия с пользователем.

**Поток:**

1. Запустить агента для плана контрольной точки
2. Агент работает до задачи контрольной точки или гейта авторизации → возвращает структурированное состояние
3. Возврат агента включает: таблицу завершённых задач, текущую задачу + блокер, тип/детали контрольной точки, что ожидается
4. **Представить пользователю:**
   ```
   ## Контрольная точка: [Тип]

   **План:** 03-03 Макет дашборда
   **Прогресс:** 2/3 задачи завершены

   [Детали контрольной точки из возврата агента]
   [Секция ожидания из возврата агента]
   ```
5. Пользователь отвечает: "утверждено"/"готово" | описание проблемы | выбор решения
6. **Запустить агента продолжения (НЕ возобновление)** используя шаблон continuation-prompt.md:
   - `{completed_tasks_table}`: Из возврата контрольной точки
   - `{resume_task_number}` + `{resume_task_name}`: Текущая задача
   - `{user_response}`: Что предоставил пользователь
   - `{resume_instructions}`: На основе типа контрольной точки
7. Агент продолжения проверяет предыдущие коммиты, продолжает с точки возобновления
8. Повторять пока план не завершится или пользователь не остановит

**Почему свежий агент, а не возобновление:** Возобновление полагается на внутреннюю сериализацию, которая ломается при параллельных вызовах инструментов. Свежие агенты с явным состоянием надёжнее.

**Контрольные точки в параллельных волнах:** Агент приостанавливается и возвращается, пока другие параллельные агенты могут завершиться. Представить контрольную точку, запустить продолжение, дождаться всех перед следующей волной.
</step>

<step name="aggregate_results">
После всех волн:

```markdown
## Фаза {X}: {Название} — Выполнение завершено

**Волны:** {N} | **Планы:** {M}/{total} завершено

| Волна | Планы | Статус |
|-------|-------|--------|
| 1 | план-01, план-02 | ✓ Завершено |
| КТ | план-03 | ✓ Проверено |
| 2 | план-04 | ✓ Завершено |

### Детали планов
1. **03-01**: [однострочник из SUMMARY.md]
2. **03-02**: [однострочник из SUMMARY.md]

### Обнаруженные проблемы
[Агрегация из SUMMARY, или "Нет"]
```
</step>

<step name="verify_phase_goal">
Проверить что фаза достигла своей ЦЕЛИ, а не просто выполнила задачи.

```
Task(
  prompt="Verify phase {phase_number} goal achievement.
Phase directory: {phase_dir}
Phase goal: {goal from ROADMAP.md}
Check must_haves against actual codebase. Create VERIFICATION.md.",
  subagent_type="gsd-verifier",
  model="{verifier_model}"
)
```

Прочитать статус:
```bash
grep "^status:" "$PHASE_DIR"/*-VERIFICATION.md | cut -d: -f2 | tr -d ' '
```

| Статус | Действие |
|--------|----------|
| `passed` | → update_roadmap |
| `human_needed` | Представить пункты для ручного тестирования, получить утверждение или обратную связь |
| `gaps_found` | Представить резюме пробелов, предложить `/gsd:plan-phase {phase} --gaps` |

**Если human_needed:**
```
## ✓ Фаза {X}: {Название} — Требуется ручная проверка

Все автоматические проверки пройдены. {N} пунктов требуют ручного тестирования:

{Из секции human_verification в VERIFICATION.md}

"утверждено" → продолжить | Сообщить о проблемах → закрытие пробелов
```

**Если gaps_found:**
```
## ⚠ Фаза {X}: {Название} — Обнаружены пробелы

**Оценка:** {N}/{M} обязательных элементов проверено
**Отчёт:** {phase_dir}/{phase}-VERIFICATION.md

### Что отсутствует
{Резюме пробелов из VERIFICATION.md}

---
## ▶ Далее

`/gsd:plan-phase {X} --gaps`

<sub>`/clear` сначала → свежее контекстное окно</sub>

Также: `cat {phase_dir}/{phase}-VERIFICATION.md` — полный отчёт
Также: `/gsd:verify-work {X}` — сначала ручное тестирование
```

Цикл закрытия пробелов: `/gsd:plan-phase {X} --gaps` читает VERIFICATION.md → создаёт планы закрытия пробелов с `gap_closure: true` → пользователь запускает `/gsd:execute-phase {X} --gaps-only` → верификатор перезапускается.
</step>

<step name="update_roadmap">
Отметить фазу завершённой в ROADMAP.md (дата, статус).

```bash
node ~/.claude/get-shit-done/bin/gsd-tools.js commit "docs(phase-{X}): complete phase execution" --files .planning/ROADMAP.md .planning/STATE.md .planning/phases/{phase_dir}/*-VERIFICATION.md .planning/REQUIREMENTS.md
```
</step>

<step name="offer_next">

**Если есть ещё фазы:**
```
## Далее

**Фаза {X+1}: {Название}** — {Цель}

`/gsd:plan-phase {X+1}`

<sub>`/clear` сначала для свежего контекста</sub>
```

**Если веха завершена:**
```
ВЕХА ЗАВЕРШЕНА!

Все {N} фаз выполнены.

`/gsd:complete-milestone`
```
</step>

</process>

<context_efficiency>
Оркестратор: ~10-15% контекста. Субагенты: свежие 200k каждый. Без опроса (Task блокирует). Без утечки контекста.
</context_efficiency>

<failure_handling>
- **Ложный сбой classifyHandoffIfNeeded:** Агент сообщает "failed" но ошибка `classifyHandoffIfNeeded is not defined` → баг Claude Code, не GSD. Выборочная проверка (SUMMARY существует, коммиты есть) → если проверка пройдена, считать успехом
- **Агент падает в середине плана:** Отсутствует SUMMARY.md → сообщить, спросить пользователя
- **Цепочка зависимостей ломается:** Волна 1 провалена → зависимые в Волне 2 вероятно провалятся → пользователь выбирает попытаться или пропустить
- **Все агенты в волне провалены:** Системная проблема → остановить, отчитаться для расследования
- **Контрольная точка неразрешима:** "Пропустить этот план?" или "Прервать выполнение фазы?" → записать частичный прогресс в STATE.md
</failure_handling>

<resumption>
Повторный запуск `/gsd:execute-phase {phase}` → discover_plans находит завершённые SUMMARY → пропускает их → возобновляет с первого незавершённого плана → продолжает волновое выполнение.

STATE.md отслеживает: последний завершённый план, текущую волну, ожидающие контрольные точки.
</resumption>