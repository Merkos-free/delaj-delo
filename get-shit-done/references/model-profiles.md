# Профили моделей

Профили моделей управляют тем, какую модель Claude использует каждый агент GSD. Это позволяет балансировать качество и расход токенов.

## Определения профилей

| Агент | `quality` | `balanced` | `budget` |
|-------|-----------|------------|----------|
| gsd-planner | opus | opus | sonnet |
| gsd-roadmapper | opus | sonnet | sonnet |
| gsd-executor | opus | sonnet | sonnet |
| gsd-phase-researcher | opus | sonnet | haiku |
| gsd-project-researcher | opus | sonnet | haiku |
| gsd-research-synthesizer | sonnet | sonnet | haiku |
| gsd-debugger | opus | sonnet | sonnet |
| gsd-codebase-mapper | sonnet | haiku | haiku |
| gsd-verifier | sonnet | sonnet | haiku |
| gsd-plan-checker | sonnet | sonnet | haiku |
| gsd-integration-checker | sonnet | sonnet | haiku |

## Философия профилей

**quality** — Максимальная мощность рассуждений
- Opus для всех агентов, принимающих решения
- Sonnet для верификации только на чтение
- Использовать когда: квота доступна, критическая архитектурная работа

**balanced** (по умолчанию) — Умное распределение
- Opus только для планирования (где принимаются архитектурные решения)
- Sonnet для выполнения и исследования (следует явным инструкциям)
- Sonnet для верификации (нужно рассуждение, не просто сопоставление паттернов)
- Использовать когда: обычная разработка, хороший баланс качества и стоимости

**budget** — Минимальное использование Opus
- Sonnet для всего что пишет код
- Haiku для исследования и верификации
- Использовать когда: экономия квоты, массовая работа, менее критичные фазы

## Логика разрешения

Оркестраторы разрешают модель перед запуском:

```
1. Прочитать .planning/config.json
2. Получить model_profile (по умолчанию: "balanced")
3. Найти агента в таблице выше
4. Передать параметр model в вызов Task
```

## Переключение профилей

В рантайме: `/gsd:set-profile <profile>`

По умолчанию для проекта: Задать в `.planning/config.json`:
```json
{
  "model_profile": "balanced"
}
```

## Обоснование дизайна

**Почему Opus для gsd-planner?**
Планирование включает архитектурные решения, декомпозицию целей и проектирование задач. Именно здесь качество модели даёт наибольший эффект.

**Почему Sonnet для gsd-executor?**
Исполнители следуют явным инструкциям PLAN.md. План уже содержит рассуждения; выполнение — это реализация.

**Почему Sonnet (не Haiku) для верификаторов в balanced?**
Верификация требует обратного рассуждения от цели — проверки, *обеспечивает* ли код то, что обещала фаза, а не просто сопоставления паттернов. Sonnet справляется хорошо; Haiku может пропустить тонкие пробелы.

**Почему Haiku для gsd-codebase-mapper?**
Исследование только на чтение и извлечение паттернов. Рассуждение не требуется, только структурированный вывод из содержимого файлов.