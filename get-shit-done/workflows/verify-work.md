<purpose>
Валидация построенных функций через диалоговое тестирование с постоянным состоянием. Создаёт UAT.md, который отслеживает прогресс тестирования, сохраняется после /clear и передаёт пробелы в /gsd:plan-phase --gaps.

Пользователь тестирует, Claude записывает. Один тест за раз. Ответы простым текстом.
</purpose>

<philosophy>
**Показать ожидаемое, спросить соответствует ли реальность.**

Claude представляет что ДОЛЖНО произойти. Пользователь подтверждает или описывает отличия.
- "да" / "y" / "далее" / пусто → пройдено
- Что угодно другое → записывается как проблема, серьёзность определяется автоматически

Никаких кнопок Пройдено/Провалено. Никаких вопросов о серьёзности. Просто: "Вот что должно произойти. Так и есть?"
</philosophy>

<template>
@~/.claude/get-shit-done/templates/UAT.md
</template>

<process>

<step name="initialize" priority="first">
Если $ARGUMENTS содержит номер фазы, загрузите контекст:

```bash
INIT=$(node ~/.claude/get-shit-done/bin/gsd-tools.js init verify-work "${PHASE_ARG}")
```

Разберите JSON для: `planner_model`, `checker_model`, `commit_docs`, `phase_found`, `phase_dir`, `phase_number`, `phase_name`, `has_verification`.
</step>

<step name="check_active_session">
**Сначала: Проверка активных UAT-сессий**

```bash
find .planning/phases -name "*-UAT.md" -type f 2>/dev/null | head -5
```

**Если активные сессии существуют И $ARGUMENTS не указаны:**

Прочитайте frontmatter каждого файла (status, phase) и секцию Current Test.

Отобразите встроенно:

```
## Активные UAT-сессии

| # | Фаза | Статус | Текущий тест | Прогресс |
|---|------|--------|-------------|----------|
| 1 | 04-comments | тестирование | 3. Ответ на комментарий | 2/6 |
| 2 | 05-auth | тестирование | 1. Форма входа | 0/4 |

Ответьте номером для возобновления или укажите номер фазы для начала нового.
```

Ожидайте ответа пользователя.

- Если пользователь отвечает номером (1, 2) → Загрузить этот файл, перейти к `resume_from_file`
- Если пользователь отвечает номером фазы → Обработать как новую сессию, перейти к `create_uat_file`

**Если активные сессии существуют И $ARGUMENTS указаны:**

Проверьте, существует ли сессия для этой фазы. Если да, предложите возобновить или начать заново.
Если нет, продолжите к `create_uat_file`.

**Если нет активных сессий И $ARGUMENTS не указаны:**

```
Нет активных UAT-сессий.

Укажите номер фазы для начала тестирования (например, /gsd:verify-work 4)
```

**Если нет активных сессий И $ARGUMENTS указаны:**

Продолжите к `create_uat_file`.
</step>

<step name="find_summaries">
**Найти что тестировать:**

Используйте `phase_dir` из init (или запустите init, если ещё не сделано).

```bash
ls "$phase_dir"/*-SUMMARY.md 2>/dev/null
```

Прочитайте каждый SUMMARY.md для извлечения тестируемых результатов.
</step>

<step name="extract_tests">
**Извлечение тестируемых результатов из SUMMARY.md:**

Разберите для:
1. **Достижения** — Добавленные функции/функциональность
2. **Изменения, видимые пользователю** — UI, рабочие процессы, взаимодействия

Фокус на НАБЛЮДАЕМЫХ ПОЛЬЗОВАТЕЛЕМ результатах, не на деталях реализации.

Для каждого результата создайте тест:
- name: Краткое название теста
- expected: Что пользователь должен увидеть/испытать (конкретно, наблюдаемо)

Примеры:
- Достижение: "Добавлена система вложенных комментариев с бесконечной вложенностью"
  → Тест: "Ответ на комментарий"
  → Ожидаемое: "Нажатие Ответить открывает встроенный редактор под комментарием. Отправка показывает ответ вложенным под родительским с визуальным отступом."

Пропускайте внутренние/ненаблюдаемые элементы (рефакторинги, изменения типов и т.д.).
</step>

<step name="create_uat_file">
**Создание UAT-файла со всеми тестами:**

```bash
mkdir -p "$PHASE_DIR"
```

Постройте список тестов из извлечённых результатов.

Создайте файл:

```markdown
---
status: testing
phase: XX-name
source: [список файлов SUMMARY.md]
started: [ISO метка времени]
updated: [ISO метка времени]
---

## Current Test
<!-- ПЕРЕЗАПИСЫВАТЬ каждый тест — показывает где мы находимся -->

number: 1
name: [название первого теста]
expected: |
  [что пользователь должен наблюдать]
awaiting: ответ пользователя

## Tests

### 1. [Название теста]
expected: [наблюдаемое поведение]
result: [pending]

### 2. [Название теста]
expected: [наблюдаемое поведение]
result: [pending]

...

## Summary

total: [N]
passed: 0
issues: 0
pending: [N]
skipped: 0

## Gaps

[пока нет]
```

Запишите в `.planning/phases/XX-name/{phase}-UAT.md`

Перейдите к `present_test`.
</step>

<step name="present_test">
**Представление текущего теста пользователю:**

Прочитайте секцию Current Test из UAT-файла.

Отобразите в формате контрольной точки:

```
╔══════════════════════════════════════════════════════════════╗
║  КОНТРОЛЬНАЯ ТОЧКА: Требуется верификация                     ║
╚══════════════════════════════════════════════════════════════╝

**Тест {number}: {name}**

{expected}

──────────────────────────────────────────────────────────────
→ Напишите "пройдено" или опишите что не так
──────────────────────────────────────────────────────────────
```

Ожидайте ответа пользователя (простой текст, без AskUserQuestion).
</step>

<step name="process_response">
**Обработка ответа пользователя и обновление файла:**

**Если ответ указывает на успех:**
- Пустой ответ, "да", "y", "ок", "пройдено", "pass", "далее", "next", "одобрено", "✓"

Обновите секцию Tests:
```
### {N}. {name}
expected: {expected}
result: pass
```

**Если ответ указывает на пропуск:**
- "пропустить", "skip", "не могу протестировать", "n/a"

Обновите секцию Tests:
```
### {N}. {name}
expected: {expected}
result: skipped
reason: [причина пользователя если указана]
```

**Если ответ — что угодно другое:**
- Обработать как описание проблемы

Определите серьёзность из описания:
- Содержит: crash, error, exception, fails, broken, unusable, крашится, ошибка, падает → blocker
- Содержит: doesn't work, wrong, missing, can't, не работает, неправильно, отсутствует → major
- Содержит: slow, weird, off, minor, small, медленно, странно → minor
- Содержит: color, font, spacing, alignment, visual, цвет, шрифт, отступ → cosmetic
- По умолчанию если неясно: major

Обновите секцию Tests:
```
### {N}. {name}
expected: {expected}
result: issue
reported: "{дословный ответ пользователя}"
severity: {определённая}
```

Добавьте в секцию Gaps (структурированный YAML для plan-phase --gaps):
```yaml
- truth: "{ожидаемое поведение из теста}"
  status: failed
  reason: "Пользователь сообщил: {дословный ответ пользователя}"
  severity: {определённая}
  test: {N}
  artifacts: []  # Заполняется при диагностике
  missing: []    # Заполняется при диагностике
```

**После любого ответа:**

Обновите счётчики Summary.
Обновите метку времени frontmatter.updated.

Если остались тесты → Обновите Current Test, перейдите к `present_test`
Если больше тестов нет → Перейдите к `complete_session`
</step>

<step name="resume_from_file">
**Возобновление тестирования из UAT-файла:**

Прочитайте полный UAT-файл.

Найдите первый тест с `result: [pending]`.

Объявите:
```
Возобновление: UAT Фазы {phase}
Прогресс: {passed + issues + skipped}/{total}
Проблем найдено: {количество issues}

Продолжаем с Теста {N}...
```

Обновите секцию Current Test ожидающим тестом.
Перейдите к `present_test`.
</step>

<step name="complete_session">
**Завершение тестирования и коммит:**

Обновите frontmatter:
- status: complete
- updated: [сейчас]

Очистите секцию Current Test:
```
## Current Test

[тестирование завершено]
```

Закоммитьте UAT-файл:
```bash
node ~/.claude/get-shit-done/bin/gsd-tools.js commit "test({phase}): complete UAT - {passed} passed, {issues} issues" --files ".planning/phases/XX-name/{phase}-UAT.md"
```

Представьте сводку:
```
## UAT завершён: Фаза {phase}

| Результат | Количество |
|-----------|------------|
| Пройдено  | {N}        |
| Проблем   | {N}        |
| Пропущено | {N}        |

[Если issues > 0:]
### Найденные проблемы

[Список из секции Issues]
```

**Если issues > 0:** Перейдите к `diagnose_issues`

**Если issues == 0:**
```
Все тесты пройдены. Готово к продолжению.

- `/gsd:plan-phase {next}` — Спланировать следующую фазу
- `/gsd:execute-phase {next}` — Выполнить следующую фазу
```
</step>

<step name="diagnose_issues">
**Диагностика корневых причин перед планированием исправлений:**

```
---

{N} проблем найдено. Диагностика корневых причин...

Запуск параллельных агентов отладки для исследования каждой проблемы.
```

- Загрузите рабочий процесс diagnose-issues
- Следуйте @~/.claude/get-shit-done/workflows/diagnose-issues.md
- Запустите параллельных агентов отладки для каждой проблемы
- Соберите корневые причины
- Обновите UAT.md корневыми причинами
- Перейдите к `plan_gap_closure`

Диагностика запускается автоматически — без запроса пользователя. Параллельные агенты исследуют одновременно, поэтому накладные расходы минимальны, а исправления более точны.
</step>

<step name="plan_gap_closure">
**Автопланирование исправлений из диагностированных пробелов:**

Отобразите:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 GSD ► ПЛАНИРОВАНИЕ ИСПРАВЛЕНИЙ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

◆ Запуск планировщика для закрытия пробелов...
```

Запустите gsd-planner в режиме --gaps:

```
Task(
  prompt="""
<planning_context>

**Phase:** {phase_number}
**Mode:** gap_closure

**UAT с диагнозами:**
@.planning/phases/{phase_dir}/{phase}-UAT.md

**Состояние проекта:**
@.planning/STATE.md

**Дорожная карта:**
@.planning/ROADMAP.md

</planning_context>

<downstream_consumer>
Результат используется /gsd:execute-phase
Планы должны быть исполняемыми промптами.
</downstream_consumer>
""",
  subagent_type="gsd-planner",
  model="{planner_model}",
  description="Планирование исправлений пробелов для Фазы {phase}"
)
```

По возвращении:
- **PLANNING COMPLETE:** Перейти к `verify_gap_plans`
- **PLANNING INCONCLUSIVE:** Сообщить и предложить ручное вмешательство
</step>

<step name="verify_gap_plans">
**Верификация планов исправления с проверщиком:**

Отобразите:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 GSD ► ВЕРИФИКАЦИЯ ПЛАНОВ ИСПРАВЛЕНИЯ
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

◆ Запуск проверщика планов...
```

Инициализация: `iteration_count = 1`

Запуск gsd-plan-checker:

```
Task(
  prompt="""
<verification_context>

**Phase:** {phase_number}
**Phase Goal:** Закрыть диагностированные пробелы из UAT

**Планы для верификации:**
@.planning/phases/{phase_dir}/*-PLAN.md

</verification_context>

<expected_output>
Верните одно из:
- ## VERIFICATION PASSED — все проверки пройдены
- ## ISSUES FOUND — структурированный список проблем
</expected_output>
""",
  subagent_type="gsd-plan-checker",
  model="{checker_model}",
  description="Верификация планов исправления Фазы {phase}"
)
```

По возвращении:
- **VERIFICATION PASSED:** Перейти к `present_ready`
- **ISSUES FOUND:** Перейти к `revision_loop`
</step>

<step name="revision_loop">
**Итерация планировщик ↔ проверщик до прохождения планов (макс. 3):**

**Если iteration_count < 3:**

Отобразите: `Отправка обратно планировщику для ревизии... (итерация {N}/3)`

Запуск gsd-planner с контекстом ревизии:

```
Task(
  prompt="""
<revision_context>

**Phase:** {phase_number}
**Mode:** revision

**Существующие планы:**
@.planning/phases/{phase_dir}/*-PLAN.md

**Проблемы проверщика:**
{structured_issues_from_checker}

</revision_context>

<instructions>
Прочитайте существующие файлы PLAN.md. Внесите целевые обновления для устранения проблем проверщика.
НЕ перепланируйте с нуля, если проблемы не фундаментальны.
</instructions>
""",
  subagent_type="gsd-planner",
  model="{planner_model}",
  description="Ревизия планов Фазы {phase}"
)
```

После возврата планировщика → запуск проверщика снова (логика verify_gap_plans)
Инкремент iteration_count

**Если iteration_count >= 3:**

Отобразите: `Достигнут максимум итераций. {N} проблем остаётся.`

Предложите опции:
1. Продолжить принудительно (выполнить несмотря на проблемы)
2. Дать указания (пользователь направляет, повтор)
3. Отказаться (выход, пользователь запускает /gsd:plan-phase вручную)

Ожидайте ответа пользователя.
</step>

<step name="present_ready">
**Представление завершения и следующих шагов:**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 GSD ► ИСПРАВЛЕНИЯ ГОТОВЫ ✓
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**Фаза {X}: {Название}** — {N} пробел(ов) диагностировано, {M} план(ов) исправления создано

| Пробел | Корневая причина | План исправления |
|--------|-----------------|------------------|
| {truth 1} | {root_cause} | {phase}-04 |
| {truth 2} | {root_cause} | {phase}-04 |

Планы верифицированы и готовы к выполнению.

───────────────────────────────────────────────────────────────

## ▶ Далее

**Выполнить исправления** — запустить планы исправления

`/clear` затем `/gsd:execute-phase {phase} --gaps-only`

───────────────────────────────────────────────────────────────
```
</step>

</process>

<update_rules>
**Пакетная запись для эффективности:**

Держите результаты в памяти. Записывайте в файл только когда:
1. **Найдена проблема** — Сохранить проблему немедленно
2. **Сессия завершена** — Финальная запись перед коммитом
3. **Контрольная точка** — Каждые 5 пройденных тестов (страховочная сеть)

| Секция | Правило | Когда записывается |
|--------|---------|-------------------|
| Frontmatter.status | ПЕРЕЗАПИСАТЬ | Старт, завершение |
| Frontmatter.updated | ПЕРЕЗАПИСАТЬ | При любой записи в файл |
| Current Test | ПЕРЕЗАПИСАТЬ | При любой записи в файл |
| Tests.{N}.result | ПЕРЕЗАПИСАТЬ | При любой записи в файл |
| Summary | ПЕРЕЗАПИСАТЬ | При любой записи в файл |
| Gaps | ДОБАВИТЬ | При нахождении проблемы |

При сбросе контекста: Файл показывает последнюю контрольную точку. Возобновление оттуда.
</update_rules>

<severity_inference>
**Определение серьёзности из естественного языка пользователя:**

| Пользователь говорит | Определяется |
|---------------------|-------------|
| "крашится", "ошибка", "исключение", "падает полностью" | blocker |
| "не работает", "ничего не происходит", "неправильное поведение" | major |
| "работает, но...", "медленно", "странно", "мелкая проблема" | minor |
| "цвет", "отступы", "выравнивание", "выглядит криво" | cosmetic |

По умолчанию **major** если неясно. Пользователь может исправить при необходимости.

**Никогда не спрашивайте "насколько это серьёзно?"** — просто определите и двигайтесь дальше.
</severity_inference>

<success_criteria>
- [ ] UAT-файл создан со всеми тестами из SUMMARY.md
- [ ] Тесты представлены по одному с ожидаемым поведением
- [ ] Ответы пользователя обработаны как pass/issue/skip
- [ ] Серьёзность определена из описания (никогда не спрашивается)
- [ ] Пакетная запись: при проблеме, каждые 5 прохождений, или при завершении
- [ ] Закоммичено при завершении
- [ ] Если проблемы: параллельные агенты отладки диагностируют корневые причины
- [ ] Если проблемы: gsd-planner создаёт планы исправления (режим gap_closure)
- [ ] Если проблемы: gsd-plan-checker верифицирует планы исправления
- [ ] Если проблемы: цикл ревизии до прохождения планов (макс. 3 итерации)
- [ ] Готово для `/gsd:execute-phase --gaps-only` по завершении
</success_criteria>