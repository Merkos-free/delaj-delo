<div align="center">

# ДЕЛАЙ ДЕЛО

**Легковесная и мощная система мета-промптинга, контекстной инженерии и спецификационно-ориентированной разработки для Claude Code, OpenCode и Gemini CLI.**

**Решает проблему деградации контекста — ухудшения качества по мере заполнения контекстного окна Claude.**

[![npm version](https://img.shields.io/npm/v/get-shit-done-cc?style=for-the-badge&logo=npm&logoColor=white&color=CB3837)](https://www.npmjs.com/package/get-shit-done-cc)
[![npm downloads](https://img.shields.io/npm/dm/get-shit-done-cc?style=for-the-badge&logo=npm&logoColor=white&color=CB3837)](https://www.npmjs.com/package/get-shit-done-cc)
[![Discord](https://img.shields.io/discord/1463221958777901349?style=for-the-badge&logo=discord&logoColor=white&label=Discord&color=5865F2)](https://discord.gg/5JJgD5svVS)
[![X (Twitter)](https://img.shields.io/badge/X-@gsd__foundation-000000?style=for-the-badge&logo=x&logoColor=white)](https://x.com/gsd_foundation)
[![GitHub stars](https://img.shields.io/github/stars/glittercowboy/get-shit-done?style=for-the-badge&logo=github&color=181717)](https://github.com/glittercowboy/get-shit-done)
[![License](https://img.shields.io/badge/license-MIT-blue?style=for-the-badge)](LICENSE)

<br>

```bash
npx get-shit-done-cc@latest
```

**Работает на Mac, Windows и Linux.**

<br>

![GSD Install](assets/terminal.svg)

<br>

*«Если ты чётко знаешь, что хочешь — это РЕАЛЬНО построит это для тебя. Без лишней ерунды.»*

*«Я пробовал SpecKit, OpenSpec и Taskmaster — здесь я получил лучшие результаты.»*

*«Самое мощное дополнение к моему Claude Code. Ничего переусложнённого. Буквально просто делает дело.»*

<br>

**Используется инженерами Amazon, Google, Shopify и Webflow.**

[Зачем я это создал](#зачем-я-это-создал) · [Как это работает](#как-это-работает) · [Команды](#команды) · [Почему это работает](#почему-это-работает)

</div>

---

## Зачем я это создал

Я — соло-разработчик. Я не пишу код — это делает Claude Code.

Другие инструменты спецификационно-ориентированной разработки существуют: BMAD, Speckit... Но все они, кажется, усложняют всё больше, чем нужно (церемонии спринтов, story points, синхронизации со стейкхолдерами, ретроспективы, воркфлоу в Jira), или им не хватает реального понимания общей картины того, что ты строишь. Я не софтверная компания на 50 человек. Я не хочу играть в корпоративный театр. Я просто креативный человек, который пытается создавать отличные вещи, которые работают.

Поэтому я создал GSD. Сложность — в системе, а не в вашем рабочем процессе. За кулисами: контекстная инженерия, XML-форматирование промптов, оркестрация суб-агентов, управление состоянием. Что видите вы: несколько команд, которые просто работают.

Система даёт Claude всё необходимое для выполнения работы *и* её проверки. Я доверяю этому рабочему процессу. Он просто хорошо работает.

Вот что это такое. Никакого корпоративного косплея. Просто невероятно эффективная система для последовательного создания крутых вещей с помощью Claude Code.

— **TÂCHES**

---

У вайбкодинга плохая репутация. Ты описываешь, что хочешь, ИИ генерирует код, и получаешь непоследовательный мусор, который разваливается при масштабировании.

ДелайДело это исправляет. Это слой контекстной инженерии, который делает Claude Code надёжным. Опиши свою идею, позволь системе извлечь всё необходимое, и пусть Claude Code приступает к работе.

---

## Для кого это

Для людей, которые хотят описать, что они хотят, и получить это корректно построенным — без притворства, что они управляют инженерной организацией на 50 человек.

---

## Начало работы

```bash
npx get-shit-done-cc@latest
```

Установщик предложит выбрать:
1. **Среда выполнения** — Claude Code, OpenCode, Gemini или все
2. **Расположение** — Глобально (все проекты) или локально (только текущий проект)

Проверьте командой `/gsd:help` внутри выбранной среды выполнения.

### Обновление

GSD быстро развивается. Обновляйте периодически:

```bash
npx get-shit-done-cc@latest
```

<details>
<summary><strong>Неинтерактивная установка (Docker, CI, скрипты)</strong></summary>

```bash
# Claude Code
npx get-shit-done-cc --claude --global   # Установить в ~/.claude/
npx get-shit-done-cc --claude --local    # Установить в ./.claude/

# OpenCode (open source, бесплатные модели)
npx get-shit-done-cc --opencode --global # Установить в ~/.config/opencode/

# Gemini CLI
npx get-shit-done-cc --gemini --global   # Установить в ~/.gemini/

# Все среды выполнения
npx get-shit-done-cc --all --global      # Установить во все директории
```

Используйте `--global` (`-g`) или `--local` (`-l`) чтобы пропустить выбор расположения.
Используйте `--claude`, `--opencode`, `--gemini` или `--all` чтобы пропустить выбор среды выполнения.

</details>

<details>
<summary><strong>Установка для разработки</strong></summary>

Клонируйте репозиторий и запустите установщик локально:

```bash
git clone https://github.com/glittercowboy/get-shit-done.git
cd get-shit-done
node bin/install.js --claude --local
```

Устанавливается в `./.claude/` для тестирования модификаций перед контрибьюцией.

</details>

### Рекомендуется: режим пропуска разрешений

GSD разработан для бесперебойной автоматизации. Запускайте Claude Code с:

```bash
claude --dangerously-skip-permissions
```

> [!TIP]
> Именно так GSD предназначен для использования — останавливаться для подтверждения `date` и `git commit` 50 раз подряд противоречит цели.

<details>
<summary><strong>Альтернатива: гранулярные разрешения</strong></summary>

Если вы предпочитаете не использовать этот флаг, добавьте это в `.claude/settings.json` вашего проекта:

```json
{
  "permissions": {
    "allow": [
      "Bash(date:*)",
      "Bash(echo:*)",
      "Bash(cat:*)",
      "Bash(ls:*)",
      "Bash(mkdir:*)",
      "Bash(wc:*)",
      "Bash(head:*)",
      "Bash(tail:*)",
      "Bash(sort:*)",
      "Bash(grep:*)",
      "Bash(tr:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git status:*)",
      "Bash(git log:*)",
      "Bash(git diff:*)",
      "Bash(git tag:*)"
    ]
  }
}
```

</details>

---

## Как это работает

> **Уже есть код?** Сначала выполните `/gsd:map-codebase`. Эта команда запускает параллельных агентов для анализа вашего стека, архитектуры, соглашений и проблемных мест. Затем `/gsd:new-project` знает вашу кодовую базу — вопросы фокусируются на том, что вы добавляете, а планирование автоматически загружает ваши паттерны.

### 1. Инициализация проекта

```
/gsd:new-project
```

Одна команда, один поток. Система:

1. **Вопросы** — Спрашивает, пока не поймёт вашу идею полностью (цели, ограничения, технологические предпочтения, граничные случаи)
2. **Исследование** — Запускает параллельных агентов для изучения предметной области (опционально, но рекомендуется)
3. **Требования** — Извлекает что входит в v1, v2 и что вне скоупа
4. **Дорожная карта** — Создаёт фазы, привязанные к требованиям

Вы утверждаете дорожную карту. Теперь вы готовы строить.

**Создаёт:** `PROJECT.md`, `REQUIREMENTS.md`, `ROADMAP.md`, `STATE.md`, `.planning/research/`

---

### 2. Обсуждение фазы

```
/gsd:discuss-phase 1
```

**Здесь вы формируете реализацию.**

В вашей дорожной карте есть одно-два предложения на фазу. Этого недостаточно контекста, чтобы построить что-то так, как *вы* это себе представляете. Этот шаг фиксирует ваши предпочтения до начала исследования или планирования.

Система анализирует фазу и определяет неясные области на основе того, что строится:

- **Визуальные фичи** → Верстка, плотность, взаимодействия, пустые состояния
- **API/CLI** → Формат ответа, флаги, обработка ошибок, детальность вывода
- **Контентные системы** → Структура, тон, глубина, поток
- **Организационные задачи** → Критерии группировки, именование, дубликаты, исключения

Для каждой выбранной области система спрашивает, пока вы не будете довольны. Результат — `CONTEXT.md` — передаётся напрямую в следующие два шага:

1. **Исследователь читает его** — Знает какие паттерны исследовать («пользователь хочет карточную верстку» → исследовать библиотеки карточных компонентов)
2. **Планировщик читает его** — Знает какие решения зафиксированы («бесконечная прокрутка решена» → план включает обработку скролла)

Чем глубже вы погрузитесь здесь, тем точнее система построит то, что вы хотите. Пропустите — получите разумные значения по умолчанию. Используйте — получите *ваше* видение.

**Создаёт:** `{phase}-CONTEXT.md`

---

### 3. Планирование фазы

```
/gsd:plan-phase 1
```

Система:

1. **Исследует** — Изучает как реализовать эту фазу, руководствуясь вашими решениями из CONTEXT.md
2. **Планирует** — Создаёт 2-3 атомарных плана задач с XML-структурой
3. **Проверяет** — Сверяет планы с требованиями, итерирует до прохождения

Каждый план достаточно мал для выполнения в свежем контекстном окне. Никакой деградации, никакого «Я буду более краток».

**Создаёт:** `{phase}-RESEARCH.md`, `{phase}-{N}-PLAN.md`

---

### 4. Выполнение фазы

```
/gsd:execute-phase 1
```

Система:

1. **Запускает планы волнами** — Параллельно где возможно, последовательно при зависимостях
2. **Свежий контекст на каждый план** — 200k токенов чисто для реализации, ноль накопленного мусора
3. **Коммит на каждую задачу** — Каждая задача получает свой атомарный коммит
4. **Верифицирует по целям** — Проверяет что кодовая база выполняет обещания фазы

Отойдите, вернитесь к завершённой работе с чистой git-историей.

**Создаёт:** `{phase}-{N}-SUMMARY.md`, `{phase}-VERIFICATION.md`

---

### 5. Верификация работы

```
/gsd:verify-work 1
```

**Здесь вы подтверждаете, что всё действительно работает.**

Автоматическая верификация проверяет существование кода и прохождение тестов. Но работает ли фича так, как вы ожидали? Это ваш шанс проверить.

Система:

1. **Извлекает тестируемые результаты** — Что вы теперь должны уметь делать
2. **Проводит вас по одному за раз** — «Можете ли вы войти через email?» Да/нет или опишите проблему
3. **Автоматически диагностирует сбои** — Запускает отладочных агентов для поиска причин
4. **Создаёт проверенные планы исправлений** — Готовы к немедленному повторному выполнению

Если всё проходит, вы двигаетесь дальше. Если что-то сломано, вы не дебажите вручную — просто запускаете `/gsd:execute-phase` снова с планами исправлений.

**Создаёт:** `{phase}-UAT.md`, планы исправлений при обнаружении проблем

---

### 6. Повторяйте → Завершайте → Следующая веха

```
/gsd:discuss-phase 2
/gsd:plan-phase 2
/gsd:execute-phase 2
/gsd:verify-work 2
...
/gsd:complete-milestone
/gsd:new-milestone
```

Цикл **обсуждение → планирование → выполнение → верификация** до завершения вехи.

Каждая фаза получает ваш ввод (обсуждение), надлежащее исследование (планирование), чистое выполнение (выполнение) и проверку человеком (верификация). Контекст остаётся свежим. Качество остаётся высоким.

Когда все фазы завершены, `/gsd:complete-milestone` архивирует веху и создаёт тег релиза.

Затем `/gsd:new-milestone` запускает следующую версию — тот же поток что и `new-project`, но для существующей кодовой базы. Вы описываете, что хотите построить дальше, система исследует предметную область, вы определяете скоуп требований, и она создаёт свежую дорожную карту. Каждая веха — чистый цикл: определить → построить → выпустить.

---

### Быстрый режим

```
/gsd:quick
```

**Для разовых задач, не требующих полного планирования.**

Быстрый режим даёт вам гарантии GSD (атомарные коммиты, отслеживание состояния) с ускоренным путём:

- **Те же агенты** — Планировщик + исполнитель, то же качество
- **Пропуск опциональных шагов** — Без исследования, без проверки плана, без верификатора
- **Отдельное отслеживание** — Живёт в `.planning/quick/`, не в фазах

Используйте для: исправления багов, небольших фич, изменений конфигурации, разовых задач.

```
/gsd:quick
> Что хотите сделать? «Добавить переключатель тёмной темы в настройки»
```

**Создаёт:** `.planning/quick/001-add-dark-mode-toggle/PLAN.md`, `SUMMARY.md`

---

## Почему это работает

### Контекстная инженерия

Claude Code невероятно мощный, *если* дать ему нужный контекст. Большинство людей этого не делают.

GSD берёт это на себя:

| Файл | Что делает |
|------|-----------|
| `PROJECT.md` | Видение проекта, всегда загружен |
| `research/` | Знания об экосистеме (стек, фичи, архитектура, подводные камни) |
| `REQUIREMENTS.md` | Скоупированные требования v1/v2 с привязкой к фазам |
| `ROADMAP.md` | Куда идёте, что сделано |
| `STATE.md` | Решения, блокеры, позиция — память между сессиями |
| `PLAN.md` | Атомарная задача с XML-структурой и шагами верификации |
| `SUMMARY.md` | Что произошло, что изменилось, зафиксировано в истории |
| `todos/` | Захваченные идеи и задачи на потом |

Лимиты размеров основаны на том, где качество Claude начинает деградировать. Оставайтесь в пределах — получайте стабильное превосходство.

### XML-форматирование промптов

Каждый план — структурированный XML, оптимизированный для Claude:

```xml
<task type="auto">
  <n>Создать эндпоинт логина</n>
  <files>src/app/api/auth/login/route.ts</files>
  <action>
    Использовать jose для JWT (не jsonwebtoken — проблемы с CommonJS).
    Валидировать учётные данные по таблице пользователей.
    Возвращать httpOnly cookie при успехе.
  </action>
  <verify>curl -X POST localhost:3000/api/auth/login возвращает 200 + Set-Cookie</verify>
  <done>Корректные учётные данные возвращают cookie, некорректные — 401</done>
</task>
```

Точные инструкции. Без гадания. Верификация встроена.

### Мульти-агентная оркестрация

Каждый этап использует один и тот же паттерн: тонкий оркестратор запускает специализированных агентов, собирает результаты и маршрутизирует к следующему шагу.

| Этап | Оркестратор делает | Агенты делают |
|------|-------------------|---------------|
| Исследование | Координирует, представляет находки | 4 параллельных исследователя изучают стек, фичи, архитектуру, подводные камни |
| Планирование | Валидирует, управляет итерациями | Планировщик создаёт планы, проверяющий верифицирует, цикл до прохождения |
| Выполнение | Группирует в волны, отслеживает прогресс | Исполнители реализуют параллельно, каждый со свежим контекстом 200k |
| Верификация | Представляет результаты, маршрутизирует дальше | Верификатор сверяет кодовую базу с целями, отладчики диагностируют сбои |

Оркестратор никогда не выполняет тяжёлую работу. Он запускает агентов, ждёт, интегрирует результаты.

**Результат:** Вы можете запустить целую фазу — глубокое исследование, создание и проверка нескольких планов, тысячи строк кода, написанных параллельными исполнителями, автоматическая верификация по целям — и ваше основное контекстное окно остаётся на 30-40%. Работа происходит в свежих контекстах суб-агентов. Ваша сессия остаётся быстрой и отзывчивой.

### Атомарные Git-коммиты

Каждая задача получает свой коммит сразу после завершения:

```bash
abc123f docs(08-02): завершён план регистрации пользователей
def456g feat(08-02): добавлен поток подтверждения email
hij789k feat(08-02): реализовано хеширование паролей
lmn012o feat(08-02): создан эндпоинт регистрации
```

> [!NOTE]
> **Преимущества:** Git bisect находит точную проблемную задачу. Каждая задача независимо откатываема. Чистая история для Claude в будущих сессиях. Лучшая наблюдаемость в автоматизированном ИИ-рабочем процессе.

Каждый коммит точечный, отслеживаемый и значимый.

### Модульность по дизайну

- Добавляйте фазы к текущей вехе
- Вставляйте срочную работу между фазами
- Завершайте вехи и начинайте заново
- Корректируйте планы без перестройки всего

Вы никогда не заблокированы. Система адаптируется.

---

## Команды

### Основной рабочий процесс

| Команда | Что делает |
|---------|-----------|
| `/gsd:new-project [--auto]` | Полная инициализация: вопросы → исследование → требования → дорожная карта |
| `/gsd:discuss-phase [N]` | Зафиксировать решения по реализации перед планированием |
| `/gsd:plan-phase [N]` | Исследование + план + проверка для фазы |
| `/gsd:execute-phase <N>` | Выполнить все планы параллельными волнами, верифицировать по завершении |
| `/gsd:verify-work [N]` | Ручное пользовательское приёмочное тестирование ¹ |
| `/gsd:audit-milestone` | Проверить достижение вехой определения готовности |
| `/gsd:complete-milestone` | Архивировать веху, создать тег релиза |
| `/gsd:new-milestone [name]` | Начать следующую версию: вопросы → исследование → требования → дорожная карта |

### Навигация

| Команда | Что делает |
|---------|-----------|
| `/gsd:progress` | Где я? Что дальше? |
| `/gsd:help` | Показать все команды и руководство по использованию |
| `/gsd:update` | Обновить GSD с предпросмотром изменений |
| `/gsd:join-discord` | Присоединиться к Discord-сообществу GSD |

### Браунфилд

| Команда | Что делает |
|---------|-----------|
| `/gsd:map-codebase` | Анализ существующей кодовой базы перед new-project |

### Управление фазами

| Команда | Что делает |
|---------|-----------|
| `/gsd:add-phase` | Добавить фазу в дорожную карту |
| `/gsd:insert-phase [N]` | Вставить срочную работу между фазами |
| `/gsd:remove-phase [N]` | Удалить будущую фазу, перенумеровать |
| `/gsd:list-phase-assumptions [N]` | Посмотреть предполагаемый подход Claude до планирования |
| `/gsd:plan-milestone-gaps` | Создать фазы для закрытия пробелов из аудита |

### Сессия

| Команда | Что делает |
|---------|-----------|
| `/gsd:pause-work` | Создать хэндофф при остановке в середине фазы |
| `/gsd:resume-work` | Восстановить из последней сессии |

### Утилиты

| Команда | Что делает |
|---------|-----------|
| `/gsd:settings` | Настроить профиль модели и агентов рабочего процесса |
| `/gsd:set-profile <profile>` | Переключить профиль модели (quality/balanced/budget) |
| `/gsd:add-todo [desc]` | Захватить идею на потом |
| `/gsd:check-todos` | Показать список ожидающих задач |
| `/gsd:debug [desc]` | Систематическая отладка с постоянным состоянием |
| `/gsd:quick` | Выполнить разовую задачу с гарантиями GSD |

<sup>¹ Предложено пользователем reddit OracleGreyBeard</sup>

---

## Конфигурация

GSD хранит настройки проекта в `.planning/config.json`. Настраивайте во время `/gsd:new-project` или обновляйте позже через `/gsd:settings`.

### Основные настройки

| Настройка | Варианты | По умолчанию | Что контролирует |
|-----------|----------|-------------|-----------------|
| `mode` | `yolo`, `interactive` | `interactive` | Автоматическое подтверждение vs подтверждение на каждом шаге |
| `depth` | `quick`, `standard`, `comprehensive` | `standard` | Тщательность планирования (фазы × планы) |

### Профили моделей

Контролируйте какую модель Claude использует каждый агент. Баланс между качеством и расходом токенов.

| Профиль | Планирование | Выполнение | Верификация |
|---------|-------------|-----------|-------------|
| `quality` | Opus | Opus | Sonnet |
| `balanced` (по умолчанию) | Opus | Sonnet | Sonnet |
| `budget` | Sonnet | Sonnet | Haiku |

Переключение профилей:
```
/gsd:set-profile budget
```

Или настройте через `/gsd:settings`.

### Агенты рабочего процесса

Они запускают дополнительных агентов во время планирования/выполнения. Улучшают качество, но добавляют токены и время.

| Настройка | По умолчанию | Что делает |
|-----------|-------------|-----------|
| `workflow.research` | `true` | Исследует предметную область перед планированием каждой фазы |
| `workflow.plan_check` | `true` | Верифицирует что планы достигают целей фазы перед выполнением |
| `workflow.verifier` | `true` | Подтверждает что обязательные элементы доставлены после выполнения |

Используйте `/gsd:settings` для переключения, или переопределяйте при вызове:
- `/gsd:plan-phase --skip-research`
- `/gsd:plan-phase --skip-verify`

### Выполнение

| Настройка | По умолчанию | Что контролирует |
|-----------|-------------|-----------------|
| `parallelization.enabled` | `true` | Запускать независимые планы одновременно |
| `planning.commit_docs` | `true` | Отслеживать `.planning/` в git |

### Git-ветвление

Контролируйте как GSD управляет ветками при выполнении.

| Настройка | Варианты | По умолчанию | Что делает |
|-----------|----------|-------------|-----------|
| `git.branching_strategy` | `none`, `phase`, `milestone` | `none` | Стратегия создания веток |
| `git.phase_branch_template` | строка | `gsd/phase-{phase}-{slug}` | Шаблон для веток фаз |
| `git.milestone_branch_template` | строка | `gsd/{milestone}-{slug}` | Шаблон для веток вех |

**Стратегии:**
- **`none`** — Коммиты в текущую ветку (поведение GSD по умолчанию)
- **`phase`** — Создаёт ветку на каждую фазу, мержит при завершении фазы
- **`milestone`** — Создаёт одну ветку на всю веху, мержит при завершении

При завершении вехи GSD предлагает squash merge (рекомендуется) или merge с историей.

---

## Безопасность

### Защита конфиденциальных файлов

Команды маппинга и анализа кодовой базы GSD читают файлы для понимания вашего проекта. **Защитите файлы с секретами**, добавив их в deny-список Claude Code:

1. Откройте настройки Claude Code (`.claude/settings.json` или глобальные)
2. Добавьте паттерны конфиденциальных файлов в deny-список:

```json
{
  "permissions": {
    "deny": [
      "Read(.env)",
      "Read(.env.*)",
      "Read(**/secrets/*)",
      "Read(**/*credential*)",
      "Read(**/*.pem)",
      "Read(**/*.key)"
    ]
  }
}
```

Это полностью предотвращает чтение этих файлов Claude, независимо от выполняемых команд.

> [!IMPORTANT]
> GSD включает встроенные защиты от коммита секретов, но эшелонированная защита — лучшая практика. Запретите доступ на чтение к конфиденциальным файлам как первую линию обороны.

---

## Устранение неполадок

**Команды не найдены после установки?**
- Перезапустите Claude Code для перезагрузки slash-команд
- Проверьте наличие файлов в `~/.claude/commands/gsd/` (глобально) или `./.claude/commands/gsd/` (локально)

**Команды работают не так, как ожидалось?**
- Выполните `/gsd:help` для проверки установки
- Повторно запустите `npx get-shit-done-cc` для переустановки

**Обновление до последней версии?**
```bash
npx get-shit-done-cc@latest
```

**Используете Docker или контейнеризованные среды?**

Если чтение файлов с путями через тильду (`~/.claude/...`) не работает, задайте `CLAUDE_CONFIG_DIR` перед установкой:
```bash
CLAUDE_CONFIG_DIR=/home/youruser/.claude npx get-shit-done-cc --global
```
Это гарантирует использование абсолютных путей вместо `~`, который может неправильно раскрываться в контейнерах.

### Удаление

Для полного удаления GSD:

```bash
# Глобальные установки
npx get-shit-done-cc --claude --global --uninstall
npx get-shit-done-cc --opencode --global --uninstall

# Локальные установки (текущий проект)
npx get-shit-done-cc --claude --local --uninstall
npx get-shit-done-cc --opencode --local --uninstall
```

Удаляет все команды, агенты, хуки и настройки GSD, сохраняя остальные конфигурации.

---

## Порты от сообщества

OpenCode и Gemini CLI теперь нативно поддерживаются через `npx get-shit-done-cc`.

Эти порты от сообщества стали пионерами мульти-рантайм поддержки:

| Проект | Платформа | Описание |
|--------|----------|----------|
| [gsd-opencode](https://github.com/rokicool/gsd-opencode) | OpenCode | Оригинальная адаптация для OpenCode |
| gsd-gemini (архивирован) | Gemini CLI | Оригинальная адаптация для Gemini от uberfuzzy |

---

## История звёзд

<a href="https://star-history.com/#glittercowboy/get-shit-done&Date">
 <picture>
   <source media="(prefers-color-scheme: dark)" srcset="https://api.star-history.com/svg?repos=glittercowboy/get-shit-done&type=Date&theme=dark" />
   <source media="(prefers-color-scheme: light)" srcset="https://api.star-history.com/svg?repos=glittercowboy/get-shit-done&type=Date" />
   <img alt="Star History Chart" src="https://api.star-history.com/svg?repos=glittercowboy/get-shit-done&type=Date" />
 </picture>
</a>

---

## Лицензия

Лицензия MIT. Подробности в [LICENSE](LICENSE).

---

<div align="center">

**Claude Code мощный. ДелайДело делает его надёжным.**

</div>
